#!/bin/sh

# Shell script to update SCC-data in website.
# Copyright (C) 2001-2004 Open Challenge B.V.
# Copyright (C) 2004-2005 OpenEyeT Professional Services.
# Copyright (C) 2005-2018 QNH.
# Copyright (C) 2019 Siem Korteweg.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; see the file COPYING.
# If not, write to the Free Software Foundation,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
#
# Contact information: https://sourceforge.net/projects/sysconfcollect/support

# SCC-release: 1.19.44
# ID:          $Id: scc-update 6217 2019-03-22 18:46:12Z siemkorteweg $


ProgName=${0##*/};			export ProgName

set -u

export SCC_BIN=/opt/scc-srv/bin
export SCC_CONF=/var/opt/scc-srv/conf
export SCC_DATA=/var/opt/scc-srv/data
export SCC_NEWCONF=/var/opt/scc-srv/newconfig
export SCC_WWW=${SCC_DATA}/www
export SCC_TMP=/tmp

export SHELL=/bin/sh
export LANG=C

PATH=/sbin:/usr/sbin:/usr/bin:/bin:${SCC_BIN};		export PATH

umask 077

# Some systems do not have the nice program.
nice_e="$(which nice 2>/dev/null)"
if [ ! -x "${nice_e}" ]
then
	alias nice=""
fi

if [ -d /usr/xpg4/bin ]
then
	PATH=/usr/xpg4/bin:${PATH}
fi

log_file="${SCC_DATA}/log/scc-update.log"

update_log()
{
	if [ -f ${log_file} ]
	then
		echo "$(date '+%Y-%m-%d %H:%M:%S') $*" >>${log_file}
	fi
}

postinstall()
{
	umask 022

	# For the package software that is unable to install empty directories.
	mkdir -p "${SCC_WWW}" "${SCC_CONF}" "${SCC_DATA}/log" "${SCC_DATA}/transfer/cp" "${SCC_DATA}/transfer/mail"

	chmod 770 "${SCC_WWW}"

	cd ${SCC_WWW}

	[ -f index.html ]			|| cp -p ${SCC_NEWCONF}/index.html		.
	[ -f custom/style.css ]			|| cp -p ${SCC_NEWCONF}/style.css		custom
	[ -f custom/scc-auto-realm.conf ]	|| cp -p ${SCC_NEWCONF}/scc-auto-realm.conf	custom
	[ -f ${SCC_CONF}/scc.conf ]		|| cp -p ${SCC_NEWCONF}/scc.conf		${SCC_CONF}

	warning=""
	if [ ! -d All ]
	then
		# There is no existing website. All files will be owned by root:root.
		# The administrator has to determine the correct settings.
		warning=yes

		chmod 750 custom		# Restrict default permission for BSD: template perms for realm All
		${SCC_BIN}/scc-realm -q -a All	# Make sure to use -q, otherwise scc-update will be called by scc-realm and the lockfile will cause an errror exit.

		cp ${SCC_NEWCONF}/scc-rules.conf ${SCC_NEWCONF}/scc-smt-select	All/custom
	else
		${SCC_BIN}/scc-realm --index	# Regenerate the main index.html file.

		# We renew the CGI-script in all realms.
		for wrapper in */cgi-bin/scc-wrapper.cgi
		do
			[ -f "${wrapper}" ] && cp -pf ${SCC_BIN}/scc-wrapper.cgi "${wrapper}"
		done

		# Create empty files for those generated by scc-summary and others that are new for the upcoming release.
		# This ensures they get the correct selinux context that should be preserved by scc-summary.
		for realm in *
		do
			if [ -d "${realm}/cgi-bin" ]
			then
				touch "${realm}/scc.log_date.csv" "${realm}/scc.log_host.csv"		# new in release 1.16

				# new in release 1.18
				touch "${realm}/scc-auto-realm-config.html"
				touch "${realm}/scc-rules-config.html"
				touch "${realm}/scc-smt-config.html"
			fi
		done

		# There is an existing website. Use the settings recorded in scc-update (-m option)
		if [ -f ${SCC_DATA}/transfer/mail_user_group ]
		then
			update_mail_owner "$(cat ${SCC_DATA}/transfer/mail_user_group)"
		fi
		warning="yes"
		if [ -f "${SCC_WWW}/All/index.html" ]
		then
			set dummy $(ls -ld "${SCC_WWW}/All/index.html")
			update_web_owner "${4}"
			warning=""
		fi

		[ -f All/custom/scc-rules.conf ] || cp -p ${SCC_NEWCONF}/scc-rules.conf All/custom
		[ -f All/custom/scc-smt-select ] || cp -p ${SCC_NEWCONF}/scc-smt-select All/custom

		if [ ! -f All/custom/favicon.ico ]
		then
			(
				cd All/custom
				ln -s ../../custom/favicon.ico favicon.ico
			)
		fi
	fi

	if [ "${warning}" ]
	then
		echo "WARNING: All files for the website are owned by root:root"
		echo "WARNING: To correct this, use: ${SCC_BIN}/scc-setup --activate"
		echo "WARNING: "
	fi

	if [ -x /usr/sbin/semanage -a -x /sbin/restorecon ]
	then
		sestatus="$(sestatus 2>/dev/null | awk '{ print $3 }')"
		if [ "${sestatus}" != "disabled" ]
		then
			# Add the selinux settings to survive a file system relabel (suggested by Jouk Hettema).
			# Use three separate calls to support semanage for CentOS 5.
			/usr/sbin/semanage fcontext --add --type httpd_sys_content_t		"${SCC_WWW}(/.*)?"
			/usr/sbin/semanage fcontext --add --type httpd_sys_script_exec_t	"${SCC_WWW}/All/cgi-bin(/.*)?"
			/usr/sbin/semanage fcontext --add --type httpd_sys_content_t		"${SCC_CONF}(/.*)?"
			/usr/sbin/semanage fcontext --add --type mail_spool_t			"${SCC_DATA}/transfer/mail(/.*)?"

			# Activate the settings:
			/sbin/restorecon -R ${SCC_WWW}
			/sbin/restorecon -R ${SCC_CONF}
			/sbin/restorecon -R ${SCC_DATA}/transfer/mail
		fi
	elif [ -x /usr/bin/chcon ]
	then
		# During an upgrade, the Selinux context is reset.
		/usr/bin/chcon -R system_u:object_r:httpd_sys_content_t:s0	${SCC_WWW}			2>/dev/null
		/usr/bin/chcon -R system_u:object_r:httpd_sys_script_exec_t:s0	${SCC_WWW}/All/cgi-bin		2>/dev/null
		/usr/bin/chcon -R system_u:object_r:httpd_sys_content_t:s0	${SCC_CONF}			2>/dev/null
		/usr/bin/chcon -R system_u:object_r:mail_spool_t:s0 		${SCC_DATA}/transfer/mail	2>/dev/null
	fi

	exit 0
}

preremove()
{
	if [ -x /usr/sbin/semanage ]
	then
		sestatus="$(sestatus 2>/dev/null | awk '{ print $3 }')"
		if [ "${sestatus}" != "disabled" ]
		then
			# Remove the selinux settings for the web-interface and data-transfer.
			/usr/sbin/semanage fcontext --delete "${SCC_WWW}(/.*)?"			2>/dev/null
			/usr/sbin/semanage fcontext --delete "${SCC_CONF}(/.*)?"		2>/dev/null
			/usr/sbin/semanage fcontext --delete "${SCC_DATA}/transfer/mail"	2>/dev/null
		fi
	fi

	exit 0
}

export TMP_FILE_1=${SCC_TMP}/scc_update_1_$$
rm -f ${TMP_FILE_1}

scc_auto_realm()
{
	config="${1}"

	# Global steps to perform:
	#
	# 1: Get the data of the hosts in realm All
	# 2: Produce matching actions from config file
	# 3: Check and add/remove host from realm

	# Syntax of this file is:
	# "general_data":<host>:<model>:<os>:<release>:<last_day>:<last_time>:<domain>:<runtime>:<size>:<virtualization>
	awk -F: '{ printf( "%s:%s:%s:%s\n", $2, $8, $4, $5 ) }' ${SCC_WWW}/All/scc-summary.data	|
	while read data
	do
		# 2: Produce matching actions from config file

		#data is: host:domain:os:release
		# Catch awk-messages and report them at the end.
		awk -F:	'/^[ 	]*#/	{ next }
			/^[ 	]*$/	{ next }
					{
						# Syntax of this file is:
						# <action>:<hostname>:<domain>:<OS>:<OS-release>
						pattern = sprintf( "^%s:%s:%s:%s$", $2, $3, $4, $5 )
						if ( p ~ pattern )
						{
							cnt = split( p, parts, ":" )
							print $1, parts[ 1 ], $0
							exit;		# Stop processing as soon as a match has been found.
						}
					}'					\
						p="${data}"			\
							<${config}		\
							2>>${TMP_FILE_1}
	done											|
	while read action host auto_rule
	do
		# 3: Check and add/remove host from realm

		action_done=0
		case "${action}" in
		add)	# when the host is absent, add it to the realm
			if [ ! -f ${SCC_WWW}/${realm}/scc.${host}.cur ]
			then
				${SCC_BIN}/scc-realm -q -a -L ${host} ${realm}
				action_done=1
			fi
			;;

		skip)	# when host is present, delete it from the realm
			if [ -f ${SCC_WWW}/${realm}/scc.${host}.cur ]
			then
				${SCC_BIN}/scc-realm -q -d -L ${host} ${realm}
				action_done=1
			fi
			;;
		esac

		if [ ${action_done} -eq 1 -a -f ${SCC_DATA}/log/scc-autorealm.log ]
		then
			echo "$(date '+%Y-%m-%d %H:%M:%S') ${host} ${action} ${auto_rule} [${config}]" >>${SCC_DATA}/log/scc-autorealm.log
		fi
	done

	if [ -s ${TMP_FILE_1} ]
	then
		echo "${ProgName}: configuration errors in ${config}:" >&2
		cat ${TMP_FILE_1} >&2
		exit 2
	fi
}

update_mail_owner()
{
	user_group="${1}"

	chown -R "${user_group}" ${SCC_DATA}/transfer/mail ${SCC_DATA}/log/scc-transfer.log 2>/dev/null
	echo "${user_group}" >${SCC_DATA}/transfer/mail_user_group	# Record for upgrade of scc-srv
	if [ "${user_group#*:}" ]
	then
		chgrp "${user_group#*:}" ${SCC_DATA}/log
	fi
}

update_web_owner()
{
	www_user="${1%:*}"
	chown -R ${www_user} ${SCC_DATA}/www/ ${SCC_CONF} ${SCC_DATA}/log/scc.cgi.log 2>/dev/null
	chown ${www_user} ${SCC_DATA}/log
}

lock_cfg="${SCC_WWW}/lock"
if [ -f "${lock_cfg}" ]
then
	echo "${ProgName}: another instance is active, check process ID in ${lock_cfg}" >&2
	exit 2
fi
if [ ! -w "${SCC_WWW}" ]
then
	echo "${ProgName}: insufficient permissons to generate summaries" >&2
	exit 2
fi
echo "$$" >"${lock_cfg}"

# Do not install the traps earlier, as the above exit will remove the
# lock file from the other, running invocation of this program.
trap 'rm -f ${lock_cfg} ${TMP_FILE_1}' 0
trap "exit 2" 1 2 3 15

conf_scc_web_path="$(sed -n 's/^SCC_WEB_PATH=//p' ${SCC_CONF}/scc.conf 2>/dev/null)"

SYNTAX="Syntax error, use: ${ProgName} [ -d|--directory <scc_web_path> ] [ -f|--force ] [ -m|--mail <mail_ug> ] [ -o|--option notransfer ] [--postinstall] [--preremove] [ -w|--web <web_usr> ] [ <dir> ]"

MISSING_OPT_ARG="${ProgName}: Syntax error, missing argument for option:"
opt_scc_web_path=""
force_summary=""
new_owners=""
www_user="${www_user:-}"
run_transfer=1

while [ $# -gt 0 ]
do
	case "${1}" in
	-d|--directory)	[ -z "${2:-}" ] && echo "${MISSING_OPT_ARG}: ${1}" >&2 && exit 1
			opt_scc_web_path="${2}"
			shift 2;;

	-f|--force)	force_summary="-f"
			shift 1;;

	-m|--mail)	[ -z "${2:-}" ] && echo "${MISSING_OPT_ARG}: ${1}" >&2 && exit 1
			update_mail_owner "${2}"
			new_owners="yes"
			shift 2;;

	-o|--option)	[ -z "${2:-}" ] && echo "${MISSING_OPT_ARG}: ${1}" >&2 && exit 1
			case "${2}" in
			notransfer)	run_transfer=0;;
			*)		echo "${ProgName}: unknonw argument for -o option: ${2}" >&2
					exit 1;;
			esac
			shift 2;;

	--preremove)	preremove
			exit 0;;			# Just in case preremove did not exit.

	--postinstall)	postinstall
			exit 0;;			# Just in case postinstall did not exit.

	-w|--web)	[ -z "${2:-}" ] && echo "${MISSING_OPT_ARG}: ${1}" >&2 && exit 1
			update_web_owner "${2}"
			new_owners="yes"
			shift 2;;

	*)		break;;
	esac
done

[ ! -d ${SCC_WWW} ] && exit 0		# Postinstall went wrong or did not execute??
cd ${SCC_WWW}

if [ $# -gt 1 ]
then
	echo "${SYNTAX}" >&2
	exit 2
fi
single_realm=""
if [ $# -eq 1 ]
then
	single_realm="${1}"
	if [ ! -d "${single_realm}" ]
	then
		echo "${ProgName}: realm '${1}' not found" >&2
		exit 1
	fi
fi

# No -w option used. Use the owner of the existing website.
if [ ! "${www_user}" ]
then
	set dummy $(ls -ld All)
	www_user="${4}"
fi

new_scc_web_path=""
if [ "${opt_scc_web_path}" -a "${conf_scc_web_path}" != "${opt_scc_web_path}" ]
then
	# Only change the document-root in the config-file. Use three steps as local sed might not support -i option.
	sed -e "s@^[# ]*SCC_WEB_PATH=.*@SCC_WEB_PATH=${opt_scc_web_path}@" ${SCC_CONF}/scc.conf >${SCC_CONF}/scc.conf.tmp
	cat ${SCC_CONF}/scc.conf.tmp >${SCC_CONF}/scc.conf	# preserve permissions
	rm -f ${SCC_CONF}/scc.conf.tmp

	# Check whether scc.conf contained SCC_WEB_PATH in the first place.
	grep -l "^SCC_WEB_PATH=" ${SCC_CONF}/scc.conf 2>/dev/null >/dev/null
	if [ $? -ne 0 ]
	then
		echo "SCC_WEB_PATH=${opt_scc_web_path}" >>${SCC_CONF}/scc.conf
	fi
	chown "${www_user}" ${SCC_CONF}/scc.conf	# Just in case it was removed?!?

	new_scc_web_path="yes"
	conf_scc_web_path="${opt_scc_web_path}"
fi

update_log "start"

NO_FILES=0
transfer_result=3
if [ "${run_transfer}" -eq 1 ]
then
	if [ ! "${single_realm}" ]
	then
		nice ${SCC_BIN}/scc-transfer
		transfer_result=$?
		update_log "transfer done [${transfer_result}]"
		if [ ${transfer_result} -eq 1 -o ${transfer_result} -eq 2 ]
		then
			exit 1
		fi
	fi
fi

# Versions prior to 1.18 used absolute paths in the main index.html to help pages and style files.
# Change this to relative paths.
if [ "${new_scc_web_path}" -o -n "${force_summary}" ]
then
	STYLE="custom/style.css"
	LOGO="custom/scc-logo.png"
	FAVICON="custom/favicon.ico"
	sed	-e "s@<A HREF=.*/scc-help/\([^>][^>\"]*\)\"*>@<A HREF=\"scc-help/\1\">@"	\
		-e "s@<LINK HREF=.*${STYLE}.*REL=@<LINK HREF=\"${STYLE}\" REL=@"		\
		-e "s@<LINK HREF=.*${FAVICON}.*REL=@<LINK HREF=\"${FAVICON}\" REL=@"		\
		-e "s@<IMG SRC=.*${LOGO}\"@<IMG SRC=\"${LOGO}\"@"				\
			<index.html								\
			>index.html.tmp
	cat index.html.tmp >index.html
	rm -f index.html.tmp
fi

# When no files have been transferred, the summaries do not need to be updated.
# Except when we are updating the ownership or the document-root, these updates have to 
# be done on the summaries too.
if [	${transfer_result} -ne ${NO_FILES}	-o	\
	"${new_owners}"				-o	\
	"${new_scc_web_path}"			-o	\
	-n "${force_summary}"					]
then
	# scc_auto_realm requires an uptodate file All/scc-summary.data, so process realm All first.
	# The second run for All (via the * in the loop) will be quick as no snapshots will be
	# more recent than the summary file.
	AllDone=0			# Avoid that "All *" leads to double processing of realm All.
	for realm in All *
	do
		if [ ${AllDone} -eq 1 -a "${realm}" = "All" ]
		then
			continue
		fi

		if [ "${single_realm}" -a "${realm}" != "${single_realm}" ]
		then
			continue
		fi

		if [ -h "${realm}" ]
		then
			# Ignore a symbolic link. We will generate the summaries for the directory itself.
			continue
		fi

		if [ -d "${realm}" -a -f "${realm}/custom/scc-logo.png" -a -x "${realm}/cgi-bin/scc-wrapper.cgi" ]
		then
			update_log "realm ${realm} start"

			# Check whether this realm uses a config file to automate populating the realm.
			# Changes should not be done on the All realm.
			# Adding is not a problem (the snapshot exists already), but removing the snapshot is not a good idea.
			auto_config="${SCC_WWW}/${realm}/custom/scc-auto-realm.conf"
			if [ "${realm}" != "All" -a -f "${auto_config}" ]
			then
				# Ignore comments and empty lines in the config file.
				data="$(sed -e '/^[ 	]*#/d' -e '/^[ 	]*$/d' ${auto_config} 2>/dev/null )"
				if [ "${data}" ]		# config data remaining?
				then
					scc_auto_realm "${auto_config}"
				fi
			fi

			if [ -f scc-summary.data ]
			then
				# Determine files newer than scc-summary.data.
				newer="$(cd "${realm}"; find . -newer scc-summary.data -name "scc.*.cur")"
				if [ -z "${newer}" ]
				then
					# All snapshots are older then scc-summary.data.
					# Therefore all summaries are uptodate.
					continue
				fi
			fi

			# Make sure to call scc-summary first to remove broken symlinks in the realm.
			update_log "realm ${realm} summary"
			nice ${SCC_BIN}/scc-summary -d "${conf_scc_web_path}" ${force_summary} "${realm}"
			update_log "realm ${realm} rules"
			nice ${SCC_BIN}/scc-rules -d "${conf_scc_web_path}" "${realm}"
			update_log "realm ${realm} smt"
			nice ${SCC_BIN}/scc-smt -d "${conf_scc_web_path}" "${realm}"

			update_log "realm ${realm} end"
		fi
		AllDone=1
	done
fi

exit 0
